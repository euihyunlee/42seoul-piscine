/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   dict.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: euihlee <euihlee@student.42seoul.kr>       +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/09/11 08:16:52 by euihlee           #+#    #+#             */
/*   Updated: 2022/09/11 23:05:30 by euihlee          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "rush02.h"

// parse_dict: 같은 파일을 가리키는 손가락 두 개와 연결 리스트를 가리키는 이중 포인터가 주어지면
// 해당 파일을 읽고 파일이 subject에서 주어진 형식에 맞으면 SUCCESS를, 틀리면 ERROR를 반환.
// 파일을 읽으면서 형식에 어긋나지 않으면 필요한 값들 - 즉, key, value 문자열을 - 연결 리스트에 저장.
int	parse_dict(int fd1, int fd2, t_node **list)
{
	char	c;
	char	*key;
	char	*val;

	// fd1은 앞서가는 오른손 손가락을 나타냅니다. 파일의 첫 문자를 읽고 반환값이 1인 경우에만 와일문이 돕니다.
	// read의 반환값을 1과 비교하는 이유는 그 반환값이 성공적으로 읽은 바이트 수를 나타내기 때문입니다. 저희가
	// 문자 하나, 즉, 1 바이트를 읽어 달라고 요청했으니 그 문자를 성공적으로 읽었다면 반환값이 1이겠지요.
	while (read(fd1, &c, 1) == 1)
	{
		// 위에서 첫 문자를 읽고 그 문자를 c에 넣어 놓은 상황입니다. 주어진 형식에 의하면 파일의 첫 문자를
		// 포함한 모든 줄의 첫 문자는 숫자여야 합니다. 따라서 만일 c가 숫자가 아니라면 아무것도 하지 않고
		// ERROR를 반환합니다.
		if (!('0' <= c && c <= '9'))
			return (ERROR);
		// c가 숫자라고 가정하고 key를 읽어 봅시다. 역시 손가락 두 개를 read_key 함수로 보내 주고
		// c를 가리키는 포인터도 함께 보내 줍니다. c 안에는 아직 숫자 문자가 들어 있습니다.
		key = read_key(fd1, fd2, &c);
		// key는 숫자로만 이루어진 문자열 또는 NULL값을 가지게 됩니다.
		if (key == NULL || !skip_to_val(fd1, fd2, &c))
			// key가 NULL이라면 read_key에서 문제가 생겼다는 말이기 때문에 바로 ERROR를 반환해 줍니다.
			// key가 NULL이 아니라면 다시 양손 손가락과 문자 c를 가리키는 포인터를 들고 skip_to_val
			// 함수로 갑니다.

			// skip_to_val은 ERROR 또는 SUCCESS를 반환하는데, ERROR를 반환했을 경우에는 parse_dict도
			// 마찬가지로 ERROR를 반환합니다.
			return (ERROR);
		// 왼손과 오른손이 모두 '공백-콜론-공백' 다음으로 오는 첫 문자를 가리키고 있습니다. 이 문자가 출력 가능하지
		// 않다면 ERROR를 반환합니다.
		if (!(' ' < c && c <= '~'))
			return (ERROR);
		// 문자가 출력 가능한 문자이면 양손 손가락과 c를 가리키는 포인터를 들고 read_val로 갑니다.
		val = read_val(fd1, fd2, &c);
		if (val == NULL)
			return (ERROR);
		// read_val이 trim_spaces까지 성공적으로 실행되었다면 key 문자열, val 문자열, 그리고 앞에서
		// 들고 온 연결 리스트를 가리키는 이중 포인터를 들고 load_entry로 갑니다. 아래 문단을 읽기 전에
		// load.c에 load_entry를 들러 주세요.
		load_entry(key, val, list);
		// 잊으셨을 지 모르겠지만 지금 c는 개행 문자를 가리키고 있습니다. 즉, while문이 다시 돌 때는
		// 방금 한 작업을 다음 줄부터 반복하는 것입니다. 만약 다음 줄이 없을 경우에는 while문을 종료하고 
		// SUCCESS를 반환합니다. 이제 다시 load.c에 load 함수로 돌아가셔도 좋습니다.
	}
	return (SUCCESS);
}

// read_key: 손가락 두 개와 문자 포인터를 받아 dict의 각 줄의 앞부분에 해당한 key 문자열을 읽고 반환.
char	*read_key(int fd1, int fd2, char *c)
{
	char	*key;
	int		keylen;

	// keylen은 숫자의 길이를 나타냅니다.
	keylen = 0;
	// 저희는 c를 포인터로 들고 왔기 때문에 c 안에는 아직 숫자가 들어 있어야 합니다. 따라서 이 while문은
	// 적어도 한 번은 돌게 되어 있습니다.
	while ('0' <= *c && *c <= '9')
	{
		// 첫 번째 자리수는 숫자인 걸 확인하고 read_key로 보내 줬으니 길이를 증가시켜 줍니다.
		keylen++;
		// 오른손으로 다음 문자를 읽고 숫자형 문자라면 반복합니다. 왼손은 아직 첫 문자를 가리키고 있습니다.
		if (read(fd1, c, 1) != 1)
			return (NULL);
	}
	// while문을 벗어났다는 말은 지금 c가 가진 값이 더이상 숫자가 아닌 문자라는 말입니다. 형식에 의하면
	// c는 무조건 공백 문자이거나 콜론 문자여야 합니다. 둘 중 하나도 아니라면 else return (NULL);로
	// 바로 떨어집니다.
	if (*c == ' ' || *c == ':')
	{
		// 숫자를 다 읽었으니 길이 + 1 만큼 메모리를 할당 받습니다. + 1은 널 문자를 위한 것입니다.
		key = malloc(keylen + 1);
		if (key != NULL)
		{
			// 널 문자를 미리 넣어 주고...
			key[keylen] = '\0';
			// 이제 *왼손으로* 정확히 숫자의 길이 만큼만 할당 받은 메모리에 저장해 줍니다.
			read(fd2, key, keylen);
		}
		// key 문자열을 반환합니다. 이 상태에서 왼손과 오른손은 둘 다 각 줄의 숫자 다음으로 오는 첫 문자를 -
		// 즉, 공백 문자 또는 콜론 문자를 - 가리키고 있습니다. 
		// 다시 위에 parse_dict 함수로 돌아갑니다.
		return (key);
	}
	else
		return (NULL);
}

// skip_to_val: 오른손으로 건너뛸 수 있는 문자의 개수를 세며 파일을 계속 읽어 나갑니다. 형식에 의해서
// 더이상 건너 뛰어서는 안 될 문자를 만났다면, 오른손이 센 개수만큼 왼손도 보내 줌으로써 왼손과 오른손을
// 맞춰 줍니다. 여기서 하는 read는 손가락을 필요한 만큼 움직이기 위한 read일 뿐, 값을 저장하기 위함은 아닙니다.
int	skip_to_val(int fd1, int fd2, char *c)
{
	int		skiplen;
	int		i;
	char	*buf;

	// skiplen은 건너뛰어도 괜찮은 문자의 개수입니다. Subject에 의하면 건너뛸 수 있는 문자열은 항상 '  :  '과
	// 같은 형식을 가지게 됩니다. 즉, 콜론은 앞에 오든 뒤에 오든 정확히 한 개가 있어야 하기 때문에 skiplen을 
	// 1로 초기화한 것입니다. 관건은 콜론 앞뒤로 오는 공백 문자의 개수입니다.
	skiplen = 1;
	// 콜론 앞으로 그리고 뒤로 공백을 세기 위해서 while문을 두 번 돌려 줄 겁니다. 
	i = 0;
	while (i < 2)
	{
		// c는 아직 이전 함수인 read_key가 반환할 당시에 양손 손가락이 가리키던 문자, 즉 숫자 다음에 오는 첫 문자의
		// 값을 가지고 있습니다. 애초에 그 문자가 공백이거나 콜론이 아니었다면 read_key가 NULL을 반환했을 테니,
		// c는 무조건 둘 중 하나일 것입니다. c가 공백 문자일 동안에 skiplen을 증가시켜 주고 다음 문자를 반복해서 읽습니다.
		while (*c == ' ')
		{
			skiplen++;
			if (read(fd1, c, 1) != 1)
				return (ERROR);
		}
		// 이제 c는 더이상 공백이 아닐 것입니다. 만약 while문이 한 번 밖에 돌지 않았다면 공백 뒤에는 콜론이 무조건 있어야겠죠.
		// 이는 c가 애초에 공백이 아니었더라도 마찬가지입니다. c가 공백이 아니었으면 처음부터 콜론이었어야겠죠.
		if (i == 0 && (*c != ':' || read(fd1, c, 1) != 1))
			// c가 콜론이 아닐 경우에는 ERROR를 반환해 줍니다. 콜론이 맞다면 다음 문자를 읽습니다 (이 경우 skiplen을
			// 증가시키지 않는 이유는 위에서 1로 초기화해 줬기 때문입니다). 맨 앞에 'i == 0' 조건에
			// 의해서 이 검사는 딱 한 번 이루어집니다. while문이 다시 돌 떄는 콜론 뒤에 오는 공백의 개수만 셉니다.
			return (ERROR);
		i++;
	}
	// while문이 두 번 돌고 나왔다면 오른손은 이제 value 문자열의 첫 문자를 가리키고 있어야 합니다. 왼손도 짝을 맞춰 주기 위해서
	// 오른손이 구한 skiplen 값만큼 메모리를 할당 받은 후, 왼손을 정확히 skiplen만큼 움직여 준 다음에, 방금 할당 받은 메모리는
	// 쓸모가 없기 때문에 바로 free해 줍니다. 
	buf = malloc(skiplen);
	read(fd2, buf, skiplen);
	free(buf);
	// 다시 parse_dict 함수로 돌아갑니다.
	return (SUCCESS);
}

// read_val: read_key와 거의 동일하지만 유효성을 숫자 대신 출력 가능한 문자인지 보고 판단합니다.
char	*read_val(int fd1, int fd2, char *c)
{
	char	*val;
	int		vallen;
	char	d;

	vallen = 0;
	while (' ' <= *c && *c <= '~')
	{
		vallen++;
		if (read(fd1, c, 1) != 1)
			return (NULL);
	}
	// 출력 가능한 문자를 다 센 다음에는 꼭 개행 문자가 있어야 합니다. 그렇지 않다면 바로 else return (NULL); 합니다.
	if (*c == '\n')
	{
		val = malloc(vallen + 1);
		if (val != NULL)
		{
			// read_key와 마찬가지로 마지막에 널 문자를 미리 넣어 주고 왼손을 vallen만큼 움직여 줌으로써
			// 할당 받은 메모리에 val 문자열을 저장해 줍니다. 
			val[vallen] = '\0';
			read(fd2, val, vallen);
			// read를 한번 더 해주는 이유는 위에서 확인한 개행 문자를 왼손으로도 읽음으로써 왼손과 오른손을 맞춰 주기 위함입니다.
			read(fd2, &d, 1);
			// 공백 문자도 출력 가능하기 때문에 val 문자열 안에는 공백이 여러개 있을 수 있습니다. 공백이 여러개 올 때는 하나로
			// 줄여 주기 위해서 val 문자열을 들고 trim_space 함수로 갑니다. trim_space는 이 파일의 마지막 함수입니다.
			trim_space(val, 1);
		}
		return (val);
	}
	else
		return (NULL);
}

// trim_space: 문자열을 받아서 연속된 공백을 하나로 줄여 줍니다.
// is_space를 인자로 받는 이유는 함수를 25줄로 줄여주기 위함입니다.....
void	trim_space(char *str, int is_space)
{
	char	*tmp1;
	char	*tmp2;

	// tmp1과 tmp2는 역시 왼손과 오른손의 역할을 각자 해 줄 겁니다.
	tmp1 = str;
	tmp2 = str;
	// 먼저 오른손을 문자열의 끝까지 보내 줍니다.
	while (*tmp1)
	{
		// is_space는 함수를 처음 호출할 때 부터 1로 초기화 되어 들어옵니다.
		// 문자열이 공백으로 시작하는 경우를 고려한 것이지만 지금 보니 그럴 일이 없었겠네요...
		// is_space는 연속된 공백이 있음을 나타냅니다.
		if (is_space)
		{
			// 공백이 연속되는 와중에 또 공백을 만난다면 오른손을 한 칸 움직여 주고 바로 while문을
			// 다시 돌립니다.
			if (*tmp1 == ' ')
			{
				tmp1++;
				continue ;
			}
			// 공백이 연속되는 와중에 다른 문자를 만난다면 is_space 플래그를 내려 줍니다. 그리고 while문
			// 안에 있는 마지막 줄로 갑니다. 
			else
				is_space = 0;
		}
		// 공백이 연속되지 않은 경우에 공백 문자를 만난다면 is_space 플래그를 올려 줍니다. 그리고 while문
		// 안에 있는 마지막 줄로 갑니다.
		else if (*tmp1 == ' ')
			is_space = 1;
		// 공백이 아니거나 첫 공백일 경우에만 앞서간 오른손이 가리키는 값을 왼손이 가리키는 곳에 복사해 주고
		// 왼손과 오른손을 각각 한 칸씩 움직여 줍니다. 
		*tmp2++ = *tmp1++;
	}
	// while문이 다 돌았다면 오른손은 문자열 끝에 가 있겠지만 왼손은 연속된 공백의 개수에 따라서 덜 움직였을 수도 있습니다.
	// 왼손이 가리키는 곳이 곧 우리가 원하는 압축된 문자열의 끝을 가리키기 때문에, 그곳에 널 문자를 넣어 줍니다.
	// 기존 문자열: | h e l l o          w o r l d        \0 |
	// 압축 문자열: | h e l l o  w o r l d   \0r l d      \0 |
	//                                   L 압축 문자열의 끝
	*tmp2 = '\0';
	// 단, 이 방식은 문자열 끝에 연속된 공백이 올 경우마저 공백을 하나 남기게 됩니다. 따라서 널 문자 앞의 값이
	// 공백일 경우, 그 자리에도 널 문자를 채워 꼬리를 잘라 줍니다.
	// 기존 문자열: | h e l l o          w o r l d        \0 |
	// 압축 문자열: | h e l l o  w o r l d   \0r l d      \0 |
	// 찐막 문자열: | h e l l o  w o r l d \0\0r l d      \0 |
	//                                   L 찐막 문자열의 끝
	if (*--tmp2 == ' ')
		*tmp2 = '\0';
	// 이제 압축한 문자열을 들고 다시 parse_dict 함수로 돌아갑니다.
}
